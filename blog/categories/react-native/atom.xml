<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: React-native | License to Kill -9]]></title>
  <link href="http://blog.flaviocaetano.com/blog/categories/react-native/atom.xml" rel="self"/>
  <link href="http://blog.flaviocaetano.com/"/>
  <updated>2019-09-26T16:16:26-03:00</updated>
  <id>http://blog.flaviocaetano.com/</id>
  <author>
    <name><![CDATA[Flávio Caetano]]></name>
    <email><![CDATA[flavio@vieiracaetano.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hooking Your Hooks]]></title>
    <link href="http://blog.flaviocaetano.com/post/react-hook-hooker/"/>
    <updated>2019-08-28T18:36:39-03:00</updated>
    <id>http://blog.flaviocaetano.com/post/react-hook-hooker</id>
    <content type="html"><![CDATA[<p>Hey, I just wanted to share with you that I built a nifty little HOC to connect a hook to a
component and receive its returned value as props. This helps cleanup your Function Components since
you can split your states and effects into multiple hooks and simplify your code.</p>

<p>Imagine you have the following component:</p>

<p>```js
const MyComponent = ({ userId }) =&gt; {
  const [isLoading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [result, setResult] = useState(null);</p>

<p>const handlePressButton = useCallback(async () =&gt; {
    try {
      setLoading(true);
      setError(null);</p>

<pre><code>  const result = await fetchDataFromTheAPI(userId);

  setResult(result);
} catch(error) {
  setError(error);
} finally {
  setLoading(false);
}   }, []);
</code></pre>

<p>const [count, setCount] = useState(0);</p>

<p>const handlePressCount = useCallback(() =&gt; {
    setCount(count + 1);
  }, [count]);</p>

<p>return (
    &lt;&gt;
      {error &amp;&amp; &lt;RenderError error={error} /&gt;}
      {isLoading &amp;&amp; <Spinner></Spinner>}
      {result &amp;&amp; &lt;RenderResult result={result}&gt;}
      &lt;Counter
        count={count}
        onPress={handlePressCount}
      /&gt;
      &lt;Button onPress={handlePressButton} /&gt;
    &lt;/&gt;
  )
};</p>

<p>```</p>

<p>The code may look as clean as possible, but it could be better organized, and this is how you can do
that.</p>

<!-- more -->

<h2 id="introducing-hooked">Introducing Hooked</h2>

<p>Hooked is a HOC that sends props to a hook as argument and return its value as props to the
component. This way we can separate the previous component into two custom hooks:</p>

<p>```js
// hooks.js
const useButtonHandler = ({ userId }) =&gt; {
  const [isLoading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [result, setResult] = useState(null);</p>

<p>const handlePressButton = useCallback(async () =&gt; {
    try {
      setLoading(true);
      setError(null);</p>

<pre><code>  const result = await fetchDataFromTheAPI(userId);

  setResult(result);
} catch(error) {
  setError(error);
} finally {
  setLoading(false);
}   }, []);
</code></pre>

<p>return { isLoading, error, result, handlePressButton };
};</p>

<p>const useCounter = () =&gt; {
  const [count, setCount] = useState(0);</p>

<p>const handlePressCount = useCallback(() =&gt; {
    setCount(count + 1);
  }, [count]);</p>

<p>return { count, handlePressCount };
};</p>

<p>```</p>

<p>The return types will be merged with the previous props and the whole thing will be sent as props
to the component:</p>

<p>```js
// MyComponent.js
const MyComponent = ({
  isLoading,
  error,
  result,
  handlePressButton,
  count,
  handlePressCount
}) =&gt; (
  &lt;&gt;
    {error &amp;&amp; &lt;RenderError error={error} /&gt;}
    {isLoading &amp;&amp; <Spinner></Spinner>}
    {result &amp;&amp; &lt;RenderResult result={result}&gt;}
    &lt;Counter
      count={count}
      onPress={handlePressCount}
    /&gt;
    &lt;Button onPress={handlePressButton} /&gt;
  &lt;/&gt;
);</p>

<p>const enhance = compose(
  hooked(useButtonHandler),
  hooked(useCounter),
);</p>

<p>export default enhance(MyComponent);</p>

<p>```</p>

<p>If you’re used with HOCs or recompose, you should be familiar with HOC composition. If you’ve never
seen that before, know that <code>compose</code> is a curry function and that the order of the arguments
affects the final result.</p>

<h3 id="hooks-that-receive-arguments">Hooks that receive arguments</h3>

<p>Your hooks will receive previous props as its arguments, that’s why it’s important to be mindful of
the order of your HOCs. If one hook need a prop returned by another hook, the former needs to be
passed after the latter. Let’s change <code>useCountr</code>, so that we can only increment our counter when
it’s not loading:</p>

<p>```js
// hooks.js
const useButtonHandler = ({ userId }) =&gt; {
  const [isLoading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [result, setResult] = useState(null);</p>

<p>const handlePressButton = useCallback(async () =&gt; {
    try {
      setLoading(true);
      setError(null);</p>

<pre><code>  const result = await fetchDataFromTheAPI(userId);

  setResult(result);
} catch(error) {
  setError(error);
} finally {
  setLoading(false);
}   }, []);
</code></pre>

<p>return { isLoading, error, result, handlePressButton };
};</p>

<p>const useCounter = ({ isLoading }) =&gt; {
  const [count, setCount] = useState(0);</p>

<p>const handlePressCount = useCallback(() =&gt; {
    if (!isLoading) {
      setCount(count + 1);
    }
  }, [count]);</p>

<p>return { count, handlePressCount };
};</p>

<p><code>
</code>js
// MyComponent.js
const enhance = compose(
  hooked(useButtonHandler),
  hooked(useCounter),
);</p>

<p>```</p>

<p>Note that <code>useCounter</code> now receives an object with the attribute <code>isLoading</code>. Since we’re hooking
it after <code>useButtonHandler</code>, it will receive whatever the latter is returning, which includes
<code>isLoading</code>. If our <code>compose</code> was reversed, <code>isLoading</code> would be <code>undefined</code> in <code>useCounter</code> since
it doesn’t exist yet.</p>

<h4 id="custom-argument-mapping">Custom argument mapping</h4>

<p>By default, <code>hooked</code> passes through to the hook any props it receives, however, if you need custom
mapping of the props to arguments, you can send an optional function to do so:</p>

<p>```js
// hooks.js
const useCounter = isLoading =&gt; {
  const [count, setCount] = useState(0);</p>

<p>const handlePressCount = useCallback(() =&gt; {
    if (!isLoading) {
      setCount(count + 1);
    }
  }, [count]);</p>

<p>return { count, handlePressCount };
};</p>

<p><code>
</code>js
// MyComponent.js
const enhance = compose(
  hooked(useButtonHandler),
  hooked(useCounter, ({ isLoading }) =&gt; isLoading),
);</p>

<p>```</p>

<p><code>useCounter</code> now receives <code>isLoading</code> directly as the only argument instead of receiving an object,
so we had to map the props to that argument in our call to <code>hooked</code>.</p>

<h2 id="typescript-">Typescript ❤️</h2>

<p>If you’re awesome and use Typescript, you’ll be glad to know that <code>hooked</code> is fully compatible with
Typescript. Actually, <code>hooked</code> was implemented considering Typescript as first-class citizen.</p>

<p>Pro-tip: if you need to merge your props with the values returned by your hook, a good idea is to use
Typescript’s build-in <code>ReturnType&lt;&gt;</code>:</p>

<p>``` ts
// hooks.js
const useCounter = () =&gt; {
  …</p>

<p>return { count, handlePressCount };
};</p>

<p>export type CounterHookProps = ReturnType<typeof useCounter="">;</typeof></p>

<p><code>
</code> ts
// MyComponent.js
interface Props {
  name: string;
  userId: number;
}</p>

<p>type HookedProps = Props &amp; CounterHookProps;</p>

<p>const MyComponent = ({ name, count }: HookedProps) =&gt; (
  …
);</p>

<p>export default hooked(useCounter)(MyComponent);</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redux Sucks With React-Native]]></title>
    <link href="http://blog.flaviocaetano.com/post/redux-sucks-with-react-native/"/>
    <updated>2018-11-23T18:21:27-02:00</updated>
    <id>http://blog.flaviocaetano.com/post/redux-sucks-with-react-native</id>
    <content type="html"><![CDATA[<p>Redux is hugely widespread as <strong>the</strong> architecture for React and React-Native projects. Its
decoupled nature combined with immutability ensures a truly functional application, when used
correctly. Yes, that’s all true.</p>

<p>Redux starts to sound weird when we try to figure out where actions may be used. Specially when your
project has wrappers and HOCs, which might mean actions definitions may not be where they’re
actually used.</p>

<!-- more -->

<h3 id="an-ios-analogy">An iOS Analogy</h3>

<p>An application that uses Redux is like an iOS app whose architecture is heavily based on
communicating with <code>NSNotifications</code>: someone you don’t know who might be posting notifications that
may be listened by other unknown parties. At any moment a new entity might start listening to posted
notifications and might also start posting them. To be honest, it’s too decoupled for my taste, if
that’s even possible at all.</p>

<p>It is beautiful in theory. However, for real world applications I haven’t seen a project where I
didn’t struggle to find dispatchers or listeners at some point.</p>

<h3 id="its-worse-for-react-native">It’s worse for React-Native</h3>

<p>The “JavaScript realm” in React-Native runs in a JS VM in the native context, which are
single-threaded. Yes, this means all of the JS code in a React-Native application runs in a single
thread. There are separate threads for shadowing and UI updates, which still have to run in the main
queue, but not JS code.</p>

<p>This means that each Redux action that is dispatched is listened by every single reducer in a single
thread of your application. Competing with other JS code like your components or data processing.
Yes, you might not think so, but your app does data processing: think about your selectors or
chewing data from your API.</p>

<p>That’s not pretty. Or performant. You have to be very mindful of which actions you’re dispatching
and where you listen to them. Remember that multiple reducers might read a single action.</p>

<h3 id="it-gets-worse-if-youre-using-redux-sagas">It gets worse if you’re using Redux-sagas</h3>

<p>Redux-saga is a middleware for Redux that, poorly speaking, allow an action to trigger a function
instead of mutating your global state. A saga might also have a side-effect that dispatches new
actions.</p>

<p>Think about that.</p>

<blockquote>
  <p>An action that <em>dispatches</em> new actions.</p>
</blockquote>

<p>If that’s not the definition of a nightmare, I don’t know what is.</p>

<p>Don’t get me wrong, Redux and Redux-sagas are beautiful and may be good solutions for web
development, they just don’t work for mobile applications. You may be thinking that they do work
because there are multiple cases in the market, but then you’re missing the concept of “work”: it’s
not just a matter of being possible and execution. It’s also scaling. <strong>Redux does not scale.</strong></p>

<p>I’ve seen applications with over 120 reducers and over 150 routes. Can you imagine how the dispatch
log looks for an app that size? Do you think it’s performant? Does the application lag?</p>

<p>I’ll leave it to you to induce those answers.</p>

<h3 id="what-then">What then?</h3>

<p>I’m yet to find a performant architecture to write function applications in React-Native. If we find
a way to instantiate multiple JS VMs and have them communicating; or if Apple releases a
multi-threaded VM. Both solutions would vastly improve the performance of React-Native apps overall,
whether or not they’re using Redux.</p>

<p>In the current state of the art, the best alternative is to keep writing imperative applications for
React-Native projects. Research an architecture that best suits your application and go with it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tips to Avoid Rerendering React-Native Components]]></title>
    <link href="http://blog.flaviocaetano.com/post/tips-to-avoid-rerendering-react-native-components/"/>
    <updated>2018-06-05T17:30:00-03:00</updated>
    <id>http://blog.flaviocaetano.com/post/tips-to-avoid-rerendering-react-native-components</id>
    <content type="html"><![CDATA[<p>Building a production-ready fully architectured React-Native app means sending and updating lots of
props to your components. This means the <code>shouldUpdate -&gt; render -&gt; didUpdate</code> flow gets called a
lot. Here are a few steps on how to optimize your components to avoid rerendering unnecessarily.</p>

<!-- more -->

<h2 id="use-pure-components">Use Pure Components</h2>

<p>Pure components are, much like pure functions, components that always produce the same output, given
an input. This usually means no input side-effects, i.e., no selectors, no fetching props that were
not passed by its parent, <em>etcetera</em>.</p>

<p>You can tag your components for this performance optimization either by using stateless components
(with arrow functions), or by extending <code>React.PureComponent</code>. <code>FlatList</code> and <code>SectionList</code> are some
examples of vanilla React-Native pure components.</p>

<p>Being pure means the component is optimized to only be rendered when its input changes. In other
words, if the props don’t change, the component won’t be rerendered.</p>

<p>```js
const NameComponent = ({ name }) =&gt; <Text>{name}</Text>;</p>

<p>class NameButton extends React.PureComponent {
    render() {
        return &lt;NameComponent name={this.props.name} /&gt;;
    }
}</p>

<p>class NameScreen extends React.Component {
    render() {
        return
            &lt;NameButton
                name={this.props.name}
                onPress={this.handleNamePress}
            /&gt;;
    }
}</p>

<p>export default connect(selector)(NameScreen);</p>

<p>```</p>

<p>In the example above, both <code>NameComponent</code> and <code>NameButton</code> are pure components, while <code>NameScreen</code>
isn’t because it gets its props from a selector.</p>

<h2 id="dont-create-objects-within-render">Don’t Create Objects Within <code>render</code></h2>

<p>Pure components check for shallow equality of their props, therefore, if you create an object in your
<code>render()</code> method, when the interpreter compares it against the previous object, it will detect an
inequallity which will cause your component to rerender.</p>

<p></p>

<p>```js
const Role = ({ name, age, address, permissions: { isAdmin } }) =&gt; (
    &lt;Profile profile={{ name, age, address, isAdmin }} /&gt;
);</p>

<p>const User = ({ name, age, permissions }) =&gt; (
    &lt;Role name={name} age={age} permissions={permissions} /&gt;
);</p>

<p>export default connect(selector)(User);
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;In the example above, &lt;code&gt;Profile&lt;/code&gt; will be rendered everytime, even if the props don’t change. Instead,
</span><span class='line'>it’d be ideal if &lt;code&gt;Role&lt;/code&gt; received the &lt;code&gt;profile&lt;/code&gt; object all the way down from the selector, ready to
</span><span class='line'>be passed down to &lt;code&gt;Profile&lt;/code&gt; instead.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```js
</span><span class='line'>const Role = ({ profile }) =&gt; (
</span><span class='line'>    &lt;Profile profile={profile} /&gt;
</span><span class='line'>);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;const User = ({ profile }) =&gt; (
</span><span class='line'>    &lt;Role profile={profile} /&gt;
</span><span class='line'>);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;export default connect(selector)(User);</span></code></pre></td></tr></table></div></figure></p>

<p>Bare in mind that the value returned by <code>selector</code> changed to better accomodate our props.</p>

<h2 id="arrow-functions-are-objects">Arrow Functions Are Objects</h2>

<p>It’s easy to forget that arrow (anonymous) functions are objects too, so when you create a new one
in your <code>render()</code> method, you’re doing the same as above.</p>

<p>
<code>js
const PictureButton = ({ pictureURL }) =&gt; (
    &lt;TouchableHighlight
        onPress={() =&gt; {
            // Did press picture
        }}
    &gt;
        &lt;Image source={{ uri: pictureURL }} /&gt;
    &lt;/TouchableHighlight&gt;
);
</code>
</p>

<p>In this example, <code>TouchableHighlight</code> is always receiving a new function object, regardless of it
being hardcoded. In this case, we should have a method to handle pressing and pass it down like
<code>onPress={this.handlePicturePress}</code>.</p>

<p>You may have also noticed that we’re sending a source object to <code>Image</code>. As described in the
previous bullet, this is also troublesome. Maybe we need to revisit how <code>Image</code> receive its props.</p>

<h2 id="avoid-render-handlers">Avoid Render Handlers</h2>

<p>By render handlers, I mean methods that render components. When you have your <code>render()</code> calling
other methods, it’s easy to get lost on the good practices mentioned above and end up with something
you’d normally avoid if you were writing directly in it.</p>

<p>```js
class Profile extends React.Component {
    renderPicture = () =&gt; {
        const source = { uri: this.props.pictureURL };
        return &lt;PictureButton image={source}/&gt;l
    }</p>

<pre><code>render() {
    return (
        &lt;View&gt;
            {this.renderPicture}
            &lt;Button&gt;
        &lt;/View&gt;
    );
} } ```
</code></pre>

<p>It may look like we have fixed the <code>Image.source</code> issue, but we haven’t. That’s because we are
creating a new <code>source</code> object everytime <code>renderPicture</code> gets called, which happens when <code>render()</code> gets
called.</p>

<p>However, avoiding this practice doesn’t mean you should never do it. One good exception to this rule
is how to define a list’s item renderer. Since we should absolutely never use arrow functions, this
renderer should be defined as a handler:</p>

<p>```js
class ObjectList extends React.Component {
    renderItem = ({ item }) =&gt;
        <Text>{item.title}</Text>;</p>

<pre><code>render() {
    return &lt;FlatList renderItem={this.renderItem} /&gt;;
} } ```
</code></pre>

<hr />

<p><em>These are just a few examples of good practices for writing components. The list is endless, if
there’s anything you’d like to see here, comment below.</em></p>
]]></content>
  </entry>
  
</feed>
