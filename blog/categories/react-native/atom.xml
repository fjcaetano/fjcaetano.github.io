<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: React-native | License to Kill -9]]></title>
  <link href="http://blog.flaviocaetano.com/blog/categories/react-native/atom.xml" rel="self"/>
  <link href="http://blog.flaviocaetano.com/"/>
  <updated>2018-06-05T19:20:33-03:00</updated>
  <id>http://blog.flaviocaetano.com/</id>
  <author>
    <name><![CDATA[Flávio Caetano]]></name>
    <email><![CDATA[flavio@vieiracaetano.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tips to Avoid Rerendering React-Native Components]]></title>
    <link href="http://blog.flaviocaetano.com/post/tips-to-avoid-rerendering-react-native-components/"/>
    <updated>2018-06-05T17:30:00-03:00</updated>
    <id>http://blog.flaviocaetano.com/post/tips-to-avoid-rerendering-react-native-components</id>
    <content type="html"><![CDATA[<p>Building a production-ready fully architectured React-Native app means sending and updating lots of
props to your components. This means the <code>shouldUpdate -&gt; render -&gt; didUpdate</code> flow gets called a
lot. Here are a few steps on how to optimize your components to avoid rerendering unnecessarily.</p>

<!-- more -->

<h2 id="use-pure-components">Use Pure Components</h2>

<p>Pure components are, much like pure functions, components that always produce the same output, given
an input. This usually means no input side-effects, i.e., no selectors, no fetching props that were
not passed by its parent, <em>etcetera</em>.</p>

<p>You can tag your components for this performance optimization either by using stateless components
(with arrow functions), or by extending <code>React.PureComponent</code>. <code>FlatList</code> and <code>SectionList</code> are some
examples of vanilla React-Native pure components.</p>

<p>Being pure means the component is optimized to only be rendered when its input changes. In other
words, if the props don’t change, the component won’t be rerendered.</p>

<p>```js
const NameComponent = ({ name }) =&gt; <Text>{name}</Text>;</p>

<p>class NameButton extends React.PureComponent {
    render() {
        return &lt;NameComponent name={this.props.name} /&gt;;
    }
}</p>

<p>class NameScreen extends React.Component {
    render() {
        return
            &lt;NameButton
                name={this.props.name}
                onPress={this.handleNamePress}
            /&gt;;
    }
}</p>

<p>export default connect(selector)(NameScreen);</p>

<p>```</p>

<p>In the example above, both <code>NameComponent</code> and <code>NameButton</code> are pure components, while <code>NameScreen</code>
isn’t because it gets its props from a selector.</p>

<h2 id="dont-create-objects-within-render">Don’t Create Objects Within <code>render</code></h2>

<p>Pure components check for shallow equality of their props, therefore, if you create an object in your
<code>render()</code> method, when the interpreter compares it against the previous object, it will detect an
inequallity which will cause your component to rerender.</p>

<p></p>

<p>```js
const Role = ({ name, age, address, permissions: { isAdmin } }) =&gt; (
    &lt;Profile profile={{ name, age, address, isAdmin }} /&gt;
);</p>

<p>const User = ({ name, age, permissions }) =&gt; (
    &lt;Role name={name} age={age} permissions={permissions} /&gt;
);</p>

<p>export default connect(selector)(User);
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;In the example above, &lt;code&gt;Profile&lt;/code&gt; will be rendered everytime, even if the props don’t change. Instead,
</span><span class='line'>it’d be ideal if &lt;code&gt;Role&lt;/code&gt; received the &lt;code&gt;profile&lt;/code&gt; object all the way down from the selector, ready to
</span><span class='line'>be passed down to &lt;code&gt;Profile&lt;/code&gt; instead.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```js
</span><span class='line'>const Role = ({ profile }) =&gt; (
</span><span class='line'>    &lt;Profile profile={profile} /&gt;
</span><span class='line'>);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;const User = ({ profile }) =&gt; (
</span><span class='line'>    &lt;Role profile={profile} /&gt;
</span><span class='line'>);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;export default connect(selector)(User);</span></code></pre></td></tr></table></div></figure></p>

<p>Bare in mind that the value returned by <code>selector</code> changed to better accomodate our props.</p>

<h2 id="arrow-functions-are-objects">Arrow Functions Are Objects</h2>

<p>It’s easy to forget that arrow (anonymous) functions are objects too, so when you create a new one
in your <code>render()</code> method, you’re doing the same as above.</p>

<p>
<code>js
const PictureButton = ({ pictureURL }) =&gt; (
    &lt;TouchableHighlight
        onPress={() =&gt; {
            // Did press picture
        }}
    &gt;
        &lt;Image source={{ uri: pictureURL }} /&gt;
    &lt;/TouchableHighlight&gt;
);
</code>
</p>

<p>In this example, <code>TouchableHighlight</code> is always receiving a new function object, regardless of it
being hardcoded. In this case, we should have a method to handle pressing and pass it down like
<code>onPress={this.handlePicturePress}</code>.</p>

<p>You may have also noticed that we’re sending a source object to <code>Image</code>. As described in the
previous bullet, this is also troublesome. Maybe we need to revisit how <code>Image</code> receive its props.</p>

<h2 id="avoid-render-handlers">Avoid Render Handlers</h2>

<p>By render handlers, I mean methods that render components. When you have your <code>render()</code> calling
other methods, it’s easy to get lost on the good practices mentioned above and end up with something
you’d normally avoid if you were writing directly in it.</p>

<p>```js
class Profile extends React.Component {
    renderPicture = () =&gt; {
        const source = { uri: this.props.pictureURL };
        return &lt;PictureButton image={source}/&gt;l
    }</p>

<pre><code>render() {
    return (
        &lt;View&gt;
            {this.renderPicture}
            &lt;Button&gt;
        &lt;/View&gt;
    );
} } ```
</code></pre>

<p>It may look like we have fixed the <code>Image.source</code> issue, but we haven’t. That’s because we are
creating a new <code>source</code> object everytime <code>renderPicture</code> gets called, which happens when <code>render()</code> gets
called.</p>

<p>However, avoiding this practice doesn’t mean you should never do it. One good exception to this rule
is how to define a list’s item renderer. Since we should absolutely never use arrow functions, this
renderer should be defined as a handler:</p>

<p>```js
class ObjectList extends React.Component {
    renderItem = ({ item }) =&gt;
        <Text>{item.title}</Text>;</p>

<pre><code>render() {
    return &lt;FlatList renderItem={this.renderItem} /&gt;;
} } ```
</code></pre>

<hr />

<p><em>These are just a few examples of good practices for writing components. The list is endless, if
there’s anything you’d like to see here, comment below.</em></p>
]]></content>
  </entry>
  
</feed>
