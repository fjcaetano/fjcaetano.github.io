<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Compose | License to Kill -9]]></title>
  <link href="http://blog.flaviocaetano.com/blog/categories/compose/atom.xml" rel="self"/>
  <link href="http://blog.flaviocaetano.com/"/>
  <updated>2019-09-26T16:16:26-03:00</updated>
  <id>http://blog.flaviocaetano.com/</id>
  <author>
    <name><![CDATA[Flávio Caetano]]></name>
    <email><![CDATA[flavio@vieiracaetano.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hooking Your Hooks]]></title>
    <link href="http://blog.flaviocaetano.com/post/react-hook-hooker/"/>
    <updated>2019-08-28T18:36:39-03:00</updated>
    <id>http://blog.flaviocaetano.com/post/react-hook-hooker</id>
    <content type="html"><![CDATA[<p>Hey, I just wanted to share with you that I built a nifty little HOC to connect a hook to a
component and receive its returned value as props. This helps cleanup your Function Components since
you can split your states and effects into multiple hooks and simplify your code.</p>

<p>Imagine you have the following component:</p>

<p>```js
const MyComponent = ({ userId }) =&gt; {
  const [isLoading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [result, setResult] = useState(null);</p>

<p>const handlePressButton = useCallback(async () =&gt; {
    try {
      setLoading(true);
      setError(null);</p>

<pre><code>  const result = await fetchDataFromTheAPI(userId);

  setResult(result);
} catch(error) {
  setError(error);
} finally {
  setLoading(false);
}   }, []);
</code></pre>

<p>const [count, setCount] = useState(0);</p>

<p>const handlePressCount = useCallback(() =&gt; {
    setCount(count + 1);
  }, [count]);</p>

<p>return (
    &lt;&gt;
      {error &amp;&amp; &lt;RenderError error={error} /&gt;}
      {isLoading &amp;&amp; <Spinner></Spinner>}
      {result &amp;&amp; &lt;RenderResult result={result}&gt;}
      &lt;Counter
        count={count}
        onPress={handlePressCount}
      /&gt;
      &lt;Button onPress={handlePressButton} /&gt;
    &lt;/&gt;
  )
};</p>

<p>```</p>

<p>The code may look as clean as possible, but it could be better organized, and this is how you can do
that.</p>

<!-- more -->

<h2 id="introducing-hooked">Introducing Hooked</h2>

<p>Hooked is a HOC that sends props to a hook as argument and return its value as props to the
component. This way we can separate the previous component into two custom hooks:</p>

<p>```js
// hooks.js
const useButtonHandler = ({ userId }) =&gt; {
  const [isLoading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [result, setResult] = useState(null);</p>

<p>const handlePressButton = useCallback(async () =&gt; {
    try {
      setLoading(true);
      setError(null);</p>

<pre><code>  const result = await fetchDataFromTheAPI(userId);

  setResult(result);
} catch(error) {
  setError(error);
} finally {
  setLoading(false);
}   }, []);
</code></pre>

<p>return { isLoading, error, result, handlePressButton };
};</p>

<p>const useCounter = () =&gt; {
  const [count, setCount] = useState(0);</p>

<p>const handlePressCount = useCallback(() =&gt; {
    setCount(count + 1);
  }, [count]);</p>

<p>return { count, handlePressCount };
};</p>

<p>```</p>

<p>The return types will be merged with the previous props and the whole thing will be sent as props
to the component:</p>

<p>```js
// MyComponent.js
const MyComponent = ({
  isLoading,
  error,
  result,
  handlePressButton,
  count,
  handlePressCount
}) =&gt; (
  &lt;&gt;
    {error &amp;&amp; &lt;RenderError error={error} /&gt;}
    {isLoading &amp;&amp; <Spinner></Spinner>}
    {result &amp;&amp; &lt;RenderResult result={result}&gt;}
    &lt;Counter
      count={count}
      onPress={handlePressCount}
    /&gt;
    &lt;Button onPress={handlePressButton} /&gt;
  &lt;/&gt;
);</p>

<p>const enhance = compose(
  hooked(useButtonHandler),
  hooked(useCounter),
);</p>

<p>export default enhance(MyComponent);</p>

<p>```</p>

<p>If you’re used with HOCs or recompose, you should be familiar with HOC composition. If you’ve never
seen that before, know that <code>compose</code> is a curry function and that the order of the arguments
affects the final result.</p>

<h3 id="hooks-that-receive-arguments">Hooks that receive arguments</h3>

<p>Your hooks will receive previous props as its arguments, that’s why it’s important to be mindful of
the order of your HOCs. If one hook need a prop returned by another hook, the former needs to be
passed after the latter. Let’s change <code>useCountr</code>, so that we can only increment our counter when
it’s not loading:</p>

<p>```js
// hooks.js
const useButtonHandler = ({ userId }) =&gt; {
  const [isLoading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [result, setResult] = useState(null);</p>

<p>const handlePressButton = useCallback(async () =&gt; {
    try {
      setLoading(true);
      setError(null);</p>

<pre><code>  const result = await fetchDataFromTheAPI(userId);

  setResult(result);
} catch(error) {
  setError(error);
} finally {
  setLoading(false);
}   }, []);
</code></pre>

<p>return { isLoading, error, result, handlePressButton };
};</p>

<p>const useCounter = ({ isLoading }) =&gt; {
  const [count, setCount] = useState(0);</p>

<p>const handlePressCount = useCallback(() =&gt; {
    if (!isLoading) {
      setCount(count + 1);
    }
  }, [count]);</p>

<p>return { count, handlePressCount };
};</p>

<p><code>
</code>js
// MyComponent.js
const enhance = compose(
  hooked(useButtonHandler),
  hooked(useCounter),
);</p>

<p>```</p>

<p>Note that <code>useCounter</code> now receives an object with the attribute <code>isLoading</code>. Since we’re hooking
it after <code>useButtonHandler</code>, it will receive whatever the latter is returning, which includes
<code>isLoading</code>. If our <code>compose</code> was reversed, <code>isLoading</code> would be <code>undefined</code> in <code>useCounter</code> since
it doesn’t exist yet.</p>

<h4 id="custom-argument-mapping">Custom argument mapping</h4>

<p>By default, <code>hooked</code> passes through to the hook any props it receives, however, if you need custom
mapping of the props to arguments, you can send an optional function to do so:</p>

<p>```js
// hooks.js
const useCounter = isLoading =&gt; {
  const [count, setCount] = useState(0);</p>

<p>const handlePressCount = useCallback(() =&gt; {
    if (!isLoading) {
      setCount(count + 1);
    }
  }, [count]);</p>

<p>return { count, handlePressCount };
};</p>

<p><code>
</code>js
// MyComponent.js
const enhance = compose(
  hooked(useButtonHandler),
  hooked(useCounter, ({ isLoading }) =&gt; isLoading),
);</p>

<p>```</p>

<p><code>useCounter</code> now receives <code>isLoading</code> directly as the only argument instead of receiving an object,
so we had to map the props to that argument in our call to <code>hooked</code>.</p>

<h2 id="typescript-">Typescript ❤️</h2>

<p>If you’re awesome and use Typescript, you’ll be glad to know that <code>hooked</code> is fully compatible with
Typescript. Actually, <code>hooked</code> was implemented considering Typescript as first-class citizen.</p>

<p>Pro-tip: if you need to merge your props with the values returned by your hook, a good idea is to use
Typescript’s build-in <code>ReturnType&lt;&gt;</code>:</p>

<p>``` ts
// hooks.js
const useCounter = () =&gt; {
  …</p>

<p>return { count, handlePressCount };
};</p>

<p>export type CounterHookProps = ReturnType<typeof useCounter="">;</typeof></p>

<p><code>
</code> ts
// MyComponent.js
interface Props {
  name: string;
  userId: number;
}</p>

<p>type HookedProps = Props &amp; CounterHookProps;</p>

<p>const MyComponent = ({ name, count }: HookedProps) =&gt; (
  …
);</p>

<p>export default hooked(useCounter)(MyComponent);</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
