<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | License to Kill -9]]></title>
  <link href="http://blog.flaviocaetano.com/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://blog.flaviocaetano.com/"/>
  <updated>2018-06-05T19:20:33-03:00</updated>
  <id>http://blog.flaviocaetano.com/</id>
  <author>
    <name><![CDATA[Fl√°vio Caetano]]></name>
    <email><![CDATA[flavio@vieiracaetano.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Handling Frames in an AutoLayout Universe]]></title>
    <link href="http://blog.flaviocaetano.com/post/handling-frames-in-an-autolayout-universe/"/>
    <updated>2018-02-27T15:20:08-03:00</updated>
    <id>http://blog.flaviocaetano.com/post/handling-frames-in-an-autolayout-universe</id>
    <content type="html"><![CDATA[<p>As frameworks improves, as our knowledge of it, we should leave <a target="\_blank" href="/post/autolayout-is-hell-on-earth/">our prejudices</a>
in the past. It is without question that AutoLayout has become much beloved and
necessary as it moves forward. Its API has improved so drastically as to discard
the need for third-party libraries.</p>

<p>However, as far as AutoLayout has progressed, it may still be simpler to handle
frames in some cases. But how to join both worlds without colliding them and
throwing a bunch of warnings in your console? Or worst: in your IB‚Ä¶</p>

<!-- more -->

<h2 id="customize-layoutsubviews">Customize <code>layoutSubviews</code></h2>

<p>Depending on the simplicity of what you want to achieve, implementing your own
version of <code>layoutSubviews</code> without relying on the SDK can be simple and effective:</p>

<p><code>swift
override func layoutSubviews() {
    _ = subviews.reduce(0) { (x, view) -&gt; CGFloat in
        let size = view.intrinsicContentSize
        view.frame = CGRect(
            origin: CGPoint(x: x, y: 0),
            size: size)
        return view.frame.maxX + Constants.spacing
    }
}
</code></p>

<h2 id="adopting-intrinsiccontentsize">Adopting <code>intrinsicContentSize</code></h2>

<p>As you may have noticed in the example above, by overriding <code>intrinsicContentSize</code>
you can have a view that defines its own size without depending on constraints
or content.</p>

<p><code>swift
override var intrinsicContentSize: CGSize {
    return isExpanded ? Constants.expandedSize : Constants.regularSize
}
</code></p>

<p>Btw, it‚Äôs animatable üíñ</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Simplest Throttle/Debounce You'll Ever See]]></title>
    <link href="http://blog.flaviocaetano.com/post/the-simplest-throttle-slash-debounce-youll-ever-see/"/>
    <updated>2018-01-11T11:12:28-02:00</updated>
    <id>http://blog.flaviocaetano.com/post/the-simplest-throttle-slash-debounce-youll-ever-see</id>
    <content type="html"><![CDATA[<p>One of these days I needed a <em>debounce</em> on Swift to ensure some block of code
would only be executed once in a period of time. <em>Debounces</em> are quite simple so
I implemented a first draft of it.</p>

<p>Not long after that, I also needed a <em>throttle</em> to skip repetitive calls to a
different block of code. Not too different from a <em>debouce</em>, but not quite the
same.</p>

<!-- more -->

<p>Bouncing around in the interwebs (pun intended), searching for a simple
implementation for <em>throttle</em>, <a target="\_blank" href="https://gist.github.com/AndreyPanov/f3c9ccdf1afc99b07d919c3f119b4d9b">all</a> <a target="\_blank" href="https://github.com/webadnan/swift-debouncer">I</a> <a target="\_blank" href="https://gist.github.com/simme/b78d10f0b29325743a18c905c5512788">could</a> <a target="\_blank" href="https://stackoverflow.com/questions/27116684/how-can-i-debounce-a-method-call">find</a> <a target="\_blank" href="https://gist.github.com/pixelspark/50afabc9ce29412cca7ef6d6323da7de">was</a>
<a target="\_blank" href="https://danielemargutti.com/2017/10/19/throttle-in-swift/">nonsense</a>‚Ä¶ and
overcomplicated.</p>

<p>So I created an extension on <code>DispatchQueue</code> (where it should be):</p>

<p><div><script src='https://gist.github.com/ff3e994c4edb4991ab8280f34994beb4.js'></script>
<noscript><pre><code>import Dispatch

private var throttleWorkItems = [AnyHashable: DispatchWorkItem]()
private var lastDebounceCallTimes = [AnyHashable: DispatchTime]()
private let nilContext: AnyHashable = arc4random()

public extension DispatchQueue {
    /**
     - parameters:
         - deadline: The timespan to delay a closure execution
         - context: The context in which the throttle should be executed
         - action: The closure to be executed

     Delays a closure execution and ensures no other executions are made during deadline
     */
    public func throttle(deadline: DispatchTime, context: AnyHashable? = nil, action: @escaping () -&gt; Void) {
        let worker = DispatchWorkItem {
            defer { throttleWorkItems.removeValue(forKey: context ?? nilContext) }
            action()
        }

        asyncAfter(deadline: deadline, execute: worker)

        throttleWorkItems[context ?? nilContext]?.cancel()
        throttleWorkItems[context ?? nilContext] = worker
    }

    /**
     - parameters:
         - interval: The interval in which new calls will be ignored
         - context: The context in which the debounce should be executed
         - action: The closure to be executed

     Executes a closure and ensures no other executions will be made during the interval.
     */
    public func debounce(interval: Double, context: AnyHashable? = nil, action: @escaping () -&gt; Void) {
        if let last = lastDebounceCallTimes[context ?? nilContext], last + interval &gt; .now() {
            return
        }

        lastDebounceCallTimes[context ?? nilContext] = .now()
        async(execute: action)

        // Cleanup &amp; release context
        throttle(deadline: .now() + interval) {
            lastDebounceCallTimes.removeValue(forKey: context ?? nilContext)
        }
    }
}
</code></pre></noscript></div>
</p>

<p><em>TA DAA</em> üéâ</p>

<!-- LINKS -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protip: UIViewControllerAnimatedTransitioning + Snapshots]]></title>
    <link href="http://blog.flaviocaetano.com/post/protip-uiviewcontrolleranimatedtransitioning-plus-snapshots/"/>
    <updated>2017-12-05T18:06:12-02:00</updated>
    <id>http://blog.flaviocaetano.com/post/protip-uiviewcontrolleranimatedtransitioning-plus-snapshots</id>
    <content type="html"><![CDATA[<p>When creating custom animations for view controller transitions, it is recommended
to use snapshots of the views being animated. However, UIKit doesn‚Äôt always make
things crystal clear.</p>

<p>If you find yourself with broken autolayout or views incorrectly configured after
enabling your transition, try <strong>creating the snapshots after adding your view to
<code>containerView</code></strong>.</p>

<!-- more -->

<p>```swift
func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
    guard let fromVC = transitionContext.viewController(forKey: .from),
        let toVC = transitionContext.viewController(forKey: .to),
        let fromAnimatedView = fromVC.animatedView.snapshotView(afterScreenUpdates: true),
        let toAnimatedView = toVC.animatedView.snapshotView(afterScreenUpdates: true) else {
        return transitionContext.completeTransition(false)
    }</p>

<pre><code>let containerView = transitionContext.containerView

[fromAnimatedView, toAnimatedView].forEach(containerView.addSubview(_:))

// Now you got yourself broken views. Hooray!
... } ```
</code></pre>

<p>The code above might not work. Your <code>toVC</code>‚Äôs view might end up completely broken
and your snapshots may have the wrong frame and contents. To fix it, simply move
the snapshots creation to after adding your destination view controller‚Äôs view to
<code>transitionContext.containerView</code>.</p>

<p>If you just try it after your <code>toVC</code> has ended initializing its views (i.e. after
<code>viewDidLoad</code> has been called) it won‚Äôt work, even if you force the view to be
loaded. You truly need to create your snapshots after the <code>containerView</code>.</p>

<p>```swift
  func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
      guard let fromVC = transitionContext.viewController(forKey: .from),
          let toVC = transitionContext.viewController(forKey: .to) else {
              return transitionContext.completeTransition(false)
      }</p>

<pre><code>  let containerView = transitionContext.containerView
  containerView.addSubview(toVC.view)

  guard let fromAnimatedView = fromVC.animatedView.snapshotView(afterScreenUpdates: true),
      let toAnimatedView = toVC.animatedView.snapshotView(afterScreenUpdates: true) else {
          return transitionContext.completeTransition(true) // toVC.view was already added to the container
  }

  ...   } ```
</code></pre>

<p>Boom! Done. Now it works üéâ</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReCaptcha Reaches 1.0]]></title>
    <link href="http://blog.flaviocaetano.com/post/recaptcha-reaches-1-dot-0/"/>
    <updated>2017-11-13T15:04:44-02:00</updated>
    <id>http://blog.flaviocaetano.com/post/recaptcha-reaches-1-dot-0</id>
    <content type="html"><![CDATA[<p>With the new Swift 4 support, <a target="_blank" href="https://github.com/fjcaetano/ReCaptcha">ReCaptcha</a> has finally reached a stable release!
Now you can safely use Google‚Äôs <a target="_blank" href="https://developers.google.com/recaptcha/docs/invisible">Invisible ReCaptcha</a> in your app!</p>

<p>Using the JS API, <a target="_blank" href="https://github.com/fjcaetano/ReCaptcha">ReCaptcha</a> tries to validate the challenge automatically and
retrieve a token, however, if the API can‚Äôt ensure the user is human, a challenge
may be presented.</p>

<p><img src="https://raw.githubusercontent.com/fjcaetano/ReCaptcha/master/example2.gif" alt="Example Gif 2" width="315px" />
<img src="https://raw.githubusercontent.com/fjcaetano/ReCaptcha/master/example.gif" alt="Example Gif" width="315px" /></p>

<!-- more -->

<h2 id="setup">Setup</h2>

<p>Register a new site to use <strong>Invisible reCaptcha</strong> at the <a target="_blank" href="https://www.google.com/recaptcha/admin">admin page</a>. Make sure
to add correct domain owned by you or your company!</p>

<p>This will return you two keys: a <em>Site key</em> and a <em>Secret key</em>. The former is the
public key which will be used in your frontend to start the validation. This is
the key must be used in the app. <strong>DO NOT USE THE SECRET KEY</strong>!</p>

<p>The <em>Secret key</em> is for the validation in the server side of the application!</p>

<h4 id="warning-"><em>Warning</em> ‚ö†Ô∏è</h4>

<p>Beware that this library only works for Invisible ReCaptcha keys! Make sure to
check the Invisible reCAPTCHA option when creating your <a href="https://www.google.com/recaptcha/admin">API Key</a>.</p>

<h4 id="installation">Installation</h4>

<p>You can install <a target="_blank" href="https://github.com/fjcaetano/ReCaptcha">ReCaptcha</a> using <a target="_blank" href="https://cocoapods.org/">CocoaPods</a>, <a target="_blank" href="https://github.com/Carthage/Carthage">Carthage</a> or as a submodule.
The library comes with a <a target="_blank" href="https://github.com/ReactiveX/RxSwift">RxSwift</a> extension.</p>

<h5 id="cocoapods">CocoaPods</h5>

<p>Add the following to your Podfile:</p>

<p><code>ruby
pod "ReCaptcha", '~&gt; 1.0'
# or
pod "ReCaptcha/RxSwift", '~&gt; 1.0'
</code></p>

<h5 id="carthage">Carthage</h5>

<p><code>ruby
github "fjcaetano/ReCaptcha" ~&gt; 1.0
</code></p>

<p>If you decide to use the reactive extension, be sure to link both frameworks
<code>ReCaptcha</code> and <code>ReCaptcha_RxSwift</code> to your project. The latter, simply contains
the reactive extension for the <code>ReCaptcha</code> class.</p>

<h3 id="ios-setup">iOS Setup</h3>

<p>Open your project‚Äôs <code>Info.plist</code> file and add two entries:</p>

<ul>
  <li><strong>ReCaptchaKey</strong>: The <em>Site key</em> created in the previous step.</li>
  <li><strong>ReCaptchaDomain</strong>: A valid domain registered with the key in the previous step.</li>
</ul>

<p>These values may also be sent as parameters to <code>ReCaptcha()</code> init. In this case,
the parameters will override the values in the <code>Info.plist</code>.</p>

<h2 id="code">Code</h2>

<p>Before starting the validation, you must call the <code>configureWebView(_:)</code> method.
This is for when the webview needs to be presented for the user to complete the
<a target="_blank" href="https://github.com/fjcaetano/ReCaptcha">ReCaptcha</a> challenge. If this method is not called, the validation may fail.</p>

<p><code>swift
recaptcha.configureWebView { [weak self] (webview: WKWebView) in
    // Configure webview for presentation
    // Make sure its frame is not CGRect.zero
}
</code></p>

<p>This is the moment to add AutoLayout constraints and store a reference to the webview,
which will already have a superview that is provided when starting the validation.</p>

<p>The <code>configureWebView(_:)</code> won‚Äôt necessarily be called. Only if the invisible
validation is not possible.</p>

<h3 id="validation">Validation</h3>

<p>To start the validation, <em>per se</em>, you must call the <code>validate(on:)</code> method.</p>

<p><code>swift
recaptcha.validate(on: view) { [weak self] (result: ReCaptchaResult) in
    print(try? result.dematerialize())
}
</code></p>

<p>The <code>view</code> given as parameter, must be visible, i.e. be in the active window
hierarchy, its bounds must be valid and it can‚Äôt be marked as <code>hidden</code>. This view
will contain the ReCaptcha webview as a subview.</p>

<p>By default, <a target="_blank" href="https://github.com/fjcaetano/ReCaptcha">ReCaptcha</a> won‚Äôt remove the webview from its superview, so it may
be interesting to have some clean up after the closure is called.</p>

<h3 id="error-handling">Error Handling</h3>

<p><a target="_blank" href="https://github.com/fjcaetano/ReCaptcha">ReCaptcha</a> may throw you some errors if incorrectly configured or when execution
fails. In any case, you can always try calling <code>recaptcha.reset()</code> on errors or
providing <code>resetOnError: true</code> to the <code>validate</code> method.</p>

<ul>
  <li><code>ReCaptchaError.htmlLoadError</code>: If by some reason, the library‚Äôs bundle is
unreachable, the template HTML won‚Äôt be loaded.</li>
  <li><code>ReCaptchaError.apiKeyNotFound</code>: No API key has been provided to the library.
Either set a <code>ReCaptchaKey</code> entry in the app‚Äôs <code>Info.plist</code> or pass it as argument
to <code>ReCaptcha</code>‚Äôs init.</li>
  <li><code>ReCaptchaError.baseURLNotFound</code>: No domain has been provided to the library.
Either set a <code>ReCaptchaDomain</code> entry in the app‚Äôs <code>Info.plist</code> or pass it as
argument to <code>ReCaptcha</code>‚Äôs init.</li>
  <li><code>ReCaptchaError.wrongMessageFormat</code>: This means the JS context provided an
unexpected message to the API. Shouldn‚Äôt happen, so, if it does, be sure to
<a target="_blank" href="https://github.com/fjcaetano/ReCaptcha/issues">open an issue</a>.</li>
  <li><code>ReCaptchaError.unexpected(Error)</code>: üí© happens ¬Ø\_(„ÉÑ)_/¬Ø. The only moment this
error could be thrown is if JavaScript sends an error. Shouldn‚Äôt happen, but if
it does, don‚Äôt be shy and <a target="_blank" href="https://github.com/fjcaetano/ReCaptcha/issues">open an issue</a>.</li>
</ul>

<h2 id="firewall-bypass">Firewall bypass</h2>

<p>If your firewall is blocking Google‚Äôs ReCaptcha, or if you‚Äôre behind the <a target="_blank" href="https://en.wikipedia.org/wiki/Great_Firewall">Great
Firewall of China</a>, you may use an alternate endpoint for the JS API that points
to <code>https://www.recaptcha.net/recaptcha/api.js</code>:</p>

<p><code>swift
try ReCaptcha(endpoint: .alternate)
</code></p>

<p>The default value for the <code>endpoint</code> parameter points the API to <code>https://www.google.com/recaptcha/api.js</code></p>

<h2 id="full-documentation"><strong><a target="_blank" style="text-decoration:underline" href="http://fjcaetano.github.io/ReCaptcha">Full Documentation</a></strong></h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Declarations From Extensions Cannot Be Overridden. Are You Sure?]]></title>
    <link href="http://blog.flaviocaetano.com/post/this-is-how-to-override-extension-methods/"/>
    <updated>2016-12-05T13:46:08-02:00</updated>
    <id>http://blog.flaviocaetano.com/post/this-is-how-to-override-extension-methods</id>
    <content type="html"><![CDATA[<p>If you found this post, it‚Äôs likely that you have already encountered the following compile error:</p>

<blockquote>
  <p>error: declarations from extensions cannot be overridden yet</p>

  <p>P.S. (I love the ‚Äúyet‚Äù part)</p>
</blockquote>

<p>It sucks, but it makes sense that you can‚Äôt override stuff from extensions. Or can you? It turns out, you can. <em>It‚Äôs a bit hacky though</em>. You have been warned.</p>

<p><img src="/images/extension-overriding/proceed_with_caution.jpg" alt="Proceed with Caution" /></p>

<!-- more -->

<h3 id="why-you-shouldnt">Why you shouldn‚Äôt</h3>

<p>Extensions, as the name already says, are supposed to extend/add/include methods to an existing implementation, making them one of the most beautiful things about Objective-C, and now Swift, since you can add code to a class or framework you do not own. Therefore, it makes sense that you‚Äôre not supposed to ‚Äúreplace‚Äù code in extensions, conceptually speaking. That‚Äôs why the compiler complains when you try to do it.</p>

<p>But there is an exception. Objective-C is a very dynamic language. While Swift attempts to statically dispatch most of its messages, Objective-C dynamically select which implementation to call at run time. So if we exploit our bridge between Objective-C and Swift, we can make the latter a bit more dynamic. Like this:</p>

<p>``` swift
class Spaceship: NSObject { }</p>

<p>extension Spaceship {
    @objc func travel(to destination: SpaceTimeLocation) {
        // TODO: move across universe till we eventualy get there, if we ever do‚Ä¶
    }
}</p>

<p>class TeleportMachine: Spaceship {
    override func travel(to destination: SpaceTimeLocation) {
        location = destination // yup, that easy
        ‚Ä¶
        renderUniverse() // lolwut?
    }
}
```
There you go. We have successfully drilled a wormhole through Swift‚Äôs fabric, all the way to Objective-C‚Äôs dynamic dispatch. There are limitations to this, of course. This is possible because our <code>Spaceship</code> class is a subclass of NSObject. Make it a root class, and our universe falls apart.</p>

<p>Unfortunately, if you try and make <code>travel(to:)</code> generic, you‚Äôll be using a Swift-only feature, which means you‚Äôre not exploiting the ObjC bridge.</p>

<p>So go ahead and do all the things you shouldn‚Äôt, though you can, even if it‚Äôs a bit <em>hacky</em>.</p>

<h3 id="update">Update</h3>

<p>On Swift 3 you need to define your method as ObjC compliant using <code>@objc</code>.
(Thanks <a target="\_blank" href="https://twitter.com/bgondim">@bgondim</a>)</p>

]]></content>
  </entry>
  
</feed>
