<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | License to Kill -9]]></title>
  <link href="http://blog.flaviocaetano.com/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://blog.flaviocaetano.com/"/>
  <updated>2016-04-08T18:30:41-03:00</updated>
  <id>http://blog.flaviocaetano.com/</id>
  <author>
    <name><![CDATA[Flávio Caetano]]></name>
    <email><![CDATA[flavio@vieiracaetano.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Better Way to Organize Swift Classes]]></title>
    <link href="http://blog.flaviocaetano.com/post/a-better-way-to-organize-swift-classes/"/>
    <updated>2016-04-08T16:36:53-03:00</updated>
    <id>http://blog.flaviocaetano.com/post/a-better-way-to-organize-swift-classes</id>
    <content type="html"><![CDATA[<p><blockquote><p>Code organization is a matter of hygiene</p><footer><strong>Mattt Thompson</strong> <cite><a href='http://nshipster.com/pragma/#organizing-your-code'>nshipster.com/pragma/&hellip;</a></cite></footer></blockquote></p>

<p>Having a clean, organized code means that anyone can easily maintain it. There
will be no hassles when trying to read and understand it. Being able to rapidly
find a method based on it’s scope is a gift. So I thought I’d show you my way of
organizing properties and methods within a class.</p>

<!-- more -->

<h2 id="always-use-mark">Always use MARK</h2>

<p>If you don’t use the source navigator to browse through your classes’ methods,
you’re doing it wrong.</p>

<p><a href="/images/swift-organization/scope-grouping.png" target="_blank"><img src="/images/swift-organization/scope-grouping.png" alt="Scope Grouping" /></a></p>

<p>Absolutely <strong>always</strong> use <code>// MARK:</code> to segment your code. Use it followed by hyphen to separate your
extensions and without it to separate your code logic. Use mark to separate your
properties from your methods. You may also use it to group your methods by their scope. Use
comments to group your properties by their meaning.</p>

<p><img src="/images/swift-organization/mark.png" alt="// MARK:" /></p>

<h2 id="properties-and-overridden-methods-go-first">Properties And Overridden Methods Go First</h2>

<p>One of the most important things of a subclass is knowing how it differs from its
parent, therefore, what should come first in your class file are your class’
properties and overridden methods.</p>

<p>``` swift
class UserTableViewCell: UITableViewCell {
  var user: UserViewModel! {
    didSet {
      setupUser()
    }
  }</p>

<p>// MARK: Outlets</p>

<p>@IBOutlet private weak var titleLabel: UILabel!</p>

<p>// MARK: - Overridden Methods</p>

<p>override func prepareForReuse() {
    super.prepareForReuse()</p>

<pre><code>cleanUp()   } } ```
</code></pre>

<p>Using this organization methodology, it’d be of great advantage if we could declare
properties in class extensions, however, since it’s not possible for obvious reasons,
all your properties must be declared inside the class declaration.</p>

<h2 id="put-your-public-methods-in-an-extension">Put Your Public Methods In An Extension</h2>

<p>Right after your class declaration, add an extension to implement your public
methods. That will make clear that they’re not protocol nor private methods.</p>

<p>``` swift
// MARK: - Public Methods
extension UserTableViewCell {
  // View Manipulation
  func disable() {
    alpha = 0.3
  }</p>

<p>func select() {
    backgroundColor = UIColor.greenColor()
  }</p>

<p>// MARK: Update User
  func setUserStatus(status: UserStatus) {
    user.status = status
    backgroundColor = UIColor.blueColor()
  }
}
```</p>

<h2 id="use-extensions-for-implementing-protocols">Use Extensions For Implementing Protocols</h2>

<p>This way you’re automatically grouping methods by their scope. Also, thanks to
Swift compiler, this way it’s easier to navigate through errors.</p>

<p><a href="/images/swift-organization/delegate-error.png" target="_blank"><img src="/images/swift-organization/delegate-error.png" alt="Protocol Errors" /></a></p>

<h2 id="leave-your-private-methods-last">Leave Your Private Methods Last</h2>

<p>Put your helpers and private methods in the last extension of the file. This way
you can scroll directly to the bottom to add a new method and you’ll know exactly
where to look at when searching for a helper method. Again: don’t forget to group
the methods by what they do.</p>

<p>``` swift
// MARK: - Private Methods
extension PromotedUsersTableViewCell {
  // Resource Methods
  private func loadUser() {
    UserResource.load() { user in
      self.user = user
    }
  }</p>

<p>private func loadMoreStuff() {
    // Load it
  }</p>

<pre><code>// MARK: View Setup   private func setupUser() {
titleLabel.text = user.name
backgroundColor = UIColor.whiteColor()   } } ```
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>I hope this makes your code as clear as possible. Since I’ve started doing this,
I never have to scroll through a class looking for some method or property. Honestly,
few things get me more upset than random properties thrown around some class.</p>

<p>If you have any suggestions to this organization methodology, let me know. The
cleaner the better.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RxWebSocket]]></title>
    <link href="http://blog.flaviocaetano.com/post/rxwebsocket/"/>
    <updated>2016-02-25T15:55:42-03:00</updated>
    <id>http://blog.flaviocaetano.com/post/rxwebsocket</id>
    <content type="html"><![CDATA[<p>Recently we had to integrate a chat-like comment feature to our new <a href="https://itunes.apple.com/us/app/winnin-battle-best-videos./id1073178885" target="_blank">Winnin App</a>
Our backend team decided to build it using websockets, so when it came to the
app implementation, my first thought was to search for an opensource swift framework
that did confirm to the <a href="http://tools.ietf.org/html/rfc6455" target="_blank">Websocket Protocol</a>.
We decided to go with <a href="https://github.com/daltoniam/Starscream" target="_blank">Starscream</a> since
it seemed simple and reliable enough.</p>

<!-- more -->

<p>In the first drafts of the new app, a decision was made to adopt reactive programming
in the app, more specifically <a href="https://github.com/ReactiveX/RxSwift" target="_blank">RxSwift</a>. Many sprints later, we’ve limited our
Rx use to cross-object events and network communications. Not surprisingly, we
wanted to use websockets reactively.</p>

<h2 id="rxwebsockettargetblank"><a href="https://github.com/fjcaetano/RxWebSocket" target="_blank">RxWebSocket</a></h2>

<p>We designed RxWebSocket to be as lightweight as possible, truly, just making an
abstraction layer over <a href="https://github.com/daltoniam/Starscream" target="_blank">Starscream</a> to make it reactive.</p>

<p>All you need is to listen to the <code>stream</code> property which is an <code>Observable&lt;StreamEvent&gt;</code>.</p>

<p><code>swift
public enum StreamEvent {
    case Connect
    case Disconnect(NSError?)
    case Pong
    case Text(String)
    case Data(NSData)
  }
</code></p>

<p>Using an enum as the element type allows us to have every interaction with the
websocket server in one property that is also easily filtered by message type. If
we need to know when the websocket connects, we can simply filter the stream:</p>

<p><code>swift
socket.stream
  .filter {
    switch $0 {
    case .Connect: return true
    default: return false
    }
  }
</code></p>

<p>If your websocket messages the client with a JSON object that you need to parse:</p>

<p><code>swift
socket.stream
  .flatMap { event -&gt; Observable&lt;AnyObject&gt; in
    switch event {
    case .Text(let text):
      return Observable.just(try NSJSONSerialization.JSONObjectWithData(text.dataUsingEncoding(NSUTF8StringEncoding)!, options: .AllowFragments))
    default: return Observable.empty()
    }
  }
</code></p>

<p>We know it’s still crude and quite simple, which is our intention, but we’ll improve
<a href="https://github.com/fjcaetano/RxWebSocket" target="_blank">RxWebSocket</a> with time. Every suggestion, comment, critic, PR, 
etcetera is welcome.</p>

<p>You can check an actual implementation in the example project or by running
<code>bash
pod try RxWebSocket
</code></p>

<p>Enjoy!</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift for Dummies]]></title>
    <link href="http://blog.flaviocaetano.com/post/swift-for-dummies/"/>
    <updated>2014-06-04T13:57:21-03:00</updated>
    <id>http://blog.flaviocaetano.com/post/swift-for-dummies</id>
    <content type="html"><![CDATA[<p>At WWDC 14, Apple introduced its new programming language: Swift. Nobody knows
for sure what will happen to Objective-C, but one can only guess it won’t be
around for long. My guess is that Apple will be accepting ObjC apps up till iOS
10, but that is just my guest.</p>

<!-- more -->

<p>By attending to the WWDC I had the opportunity of directly contacting Apple’s
engineers and insights most of people couldn’t, so in the next posts I’ll cover
the basics of Swift.</p>

<p>It doesn’t matter if you’re new to iOS or an experienced programmer. Now, we’re
all in the same boat. We all have to learn Swift from scratch, so forget
everything you know about Objective-C and get ready to learn this brand new
language. By the way, its potential is overwhelming.</p>

<h2 id="the-basics">The basics</h2>

<p>As far as I could tell, Swift borrows concepts from Python, Javascript and even
Java. It’s syntax also resembles these languages very much.</p>

<p>You can forget about pointers for now, most of what we’ll be using in Swift is
passed through references. No more asterisk (woohoo \o/).</p>

<p>Swift plays with the concepts of variables and constants. There’s no type
definition to neither of those just the declares var, for variables, and <code>let</code>
for constants. As you may have figured out, constants can’t be altered. We’ll
cover when to use it in a few steps.</p>

<p><div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="n">foo</span> <span class="o">=</span> <span class="err">“</span><span class="n">this</span> <span class="kt">is</span> <span class="n">getting</span> <span class="n">good</span><span class="err">”</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">42</span></code></pre></div></p>

<p>Yep, there are no semi-colons at the end of statements.</p>

<p>Switches are extremely powerful. <code>Cases</code> can be variables, strings, even a range
 of numbers. Also, cases don’t automatically fall through the next condition, so
  there’s no need to <code>break</code>.</p>

<p><div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">switch</span> <span class="n">myvar</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">4</span><span class="o">:</span>
        <span class="c1">// do something&lt;/p&gt;</span>

<span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">case</span> <span class="nl">someOtherVar</span><span class="p">:</span>
    <span class="c1">// this is getting wild</span>

<span class="k">case</span> <span class="s">&quot;string&quot;</span><span class="o">:</span>
    <span class="c1">// holy cow!</span>

<span class="k">case</span> <span class="mf">1..4</span><span class="o">:</span>
    <span class="c1">// ok, this is awesome</span>
<span class="k">default</span><span class="o">:</span>
    <span class="c1">// something unimplemented }</span></code></pre></div>
</code></pre>

<p>There’s also no need for surrounding parenthesis when working with conditions,
unless it’s a complex condition, as usual. Switches in Swift (yep, try saying
that three times) are exhaustive. That means that you must either supply <code>cases</code>
for every possible condition or a <code>default</code> to handle everything else.
XCode will error at compile time if you don’t.</p>

<p>The final topic of this post is how you’ll print output to the console. It’s as
simple as calling <code>println()</code> (it’s a function) and you’re done.
Formatting strings is also awsome:</p>

<p><div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="n">name</span> <span class="o">=</span> <span class="err">“</span><span class="n">Flavio</span><span class="err">”</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">println</span><span class="p">(</span><span class="err">“</span><span class="n">Hello</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">!</span><span class="err">”</span><span class="p">)</span>
<span class="c1">// Hello Flavio!</span></code></pre></div></p>

<p>This is enough to get started and get familiar with Swift. Go ahead, poke it
around, but don’t try to get fancy just yet. I’ll be covering more in the next
few days.</p>
]]></content>
  </entry>
  
</feed>
